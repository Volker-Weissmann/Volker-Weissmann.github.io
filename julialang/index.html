<!doctype html><!-- Adopted from: pandoc --print-default-template=html5  --><html lang=en dir=ltr> <head><link rel=icon href=/favicon.svg sizes=any type=image/svg+xml><link rel=stylesheet href=/styles.css><title>My Experiences with Julia - Volker Weißmann</title><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1.0, user-scalable=yes"><meta name=keywords content><meta name=description content="I describe my experiences using
the Julia programming language and highlight its problems of bad
performance and bad documentation. I find Julia code to be harder to
write than most other languages."></head> <body> <div id=sidebar> <nav id=TOC role=doc-toc> <h3>Table of Contents</h3> <ul> <li><a href=#why-i-chose-julia id=toc-why-i-chose-julia>Why I chose Julia</a></li> <li><a href=#tutorials-are-not-references id=toc-tutorials-are-not-references>Tutorials are not References</a> <ul> <li><a href=#the-problem-with-free-functions id=toc-the-problem-with-free-functions>The problem with free functions</a></li> </ul></li> <li><a href=#hard-to-debug-due-to-bad-error-messages id=toc-hard-to-debug-due-to-bad-error-messages>Hard to debug due to bad error messages</a></li> <li><a href=#dynamic-typing id=toc-dynamic-typing>Dynamic Typing</a></li> <li><a href=#performance id=toc-performance>Performance</a></li> <li><a href=#confusion-about-the-recommended-way. id=toc-confusion-about-the-recommended-way.>Confusion about the “recommended” way.</a></li> <li><a href=#other-stuff id=toc-other-stuff>Other Stuff</a></li> <li><a href=#conclusion id=toc-conclusion>Conclusion</a></li> <li><a href=#other-opinions id=toc-other-opinions>Other Opinions</a></li> <li><a href=#updates id=toc-updates>Updates</a></li> </ul> </nav> </div> <div id=article> <article> <h1> My Experiences with Julia </h1> <div class=abstract> <div class=abstract-title>Abstract</div> I describe my experiences using the Julia programming language and highlight its problems of bad performance and bad documentation. I find Julia code to be harder to write than most other languages. </div> <!-- If the follow line is indented, <pre> blocks in markdown will be indented, but they should not. The file extension is .nfhtml instead of .html to stop vscode from formatting on save. --> <h2 id=why-i-chose-julia><a href=#why-i-chose-julia>Why I chose Julia</a></h2> <p>In 2021, I had to do some numerical calculations for my master thesis about theoretical physics. So, I had to choose a language:</p> <p>First I thought about using python. It is commonly used for scientific calculations, mainly because of its good ergonomics, i.e. python code is shorter than e.g. equivalent C code. Dynamic typing can lead to a horrible mess in larger projects, but I knew my code would stay small. The problem with python for my use case is its poor performance. Numpy is quite fast, definitely fast enough, but if I had to manually write a hot loop in python, it would be unacceptably slow.</p> <p>A faster alternative would be C/C++. While it is definitely fast enough, its poor ergonomics would inflate the time needed for writing the code. Also, C++ has its own problems, but this is a story for another post.</p> <p>Rust is essentially C/C++, but without their ugliness. But Rust is quite a verbose language, which is fine for large projects, but not what you want for short scientific calculations.</p> <p>Julia was advertised to me as a language for scientific calculations like mine. It looks like python, has a really nice syntax for mathematical equations, but is nearly as fast as C. This is exactly what I wanted. The code would be short and clean like python, but I can write hot loops manually without completely butchering the performance. Julia is a bit slower than C, but I am not trying to squeeze out every bit of performance. So, I choose Julia, thinking that it is exactly the right language for my kind of problem… Oh boy, was I wrong.</p> <h2 id=tutorials-are-not-references><a href=#tutorials-are-not-references>Tutorials are not References</a></h2> <p>There are two different types of documentation, I will call them tutorials and references. Tutorials are what you read if you never used a library before and you want to get an overview, references are what you read if you want to e.g. now the exact set of arguments that a specific function accepts. (My seperation into two types of documentation is similar to <a href=https://documentation.divio.com>divio’s seperation into four types of documentation</a>. My “reference” is their “reference” and my “tutorials” are their “tutorial”, “how-to guides” and “explanation”.)</p> <p>Julia’s flagship libraries have great tutorials, but fall flat on their face when it comes to references. Take for example <a href=https://github.com/SciML/DifferentialEquations.jl>DifferentialEquations.jl</a>. Their <a href=https://diffeq.sciml.ai/dev/tutorials/ode_example/ >tutorial</a> is quite nice, but a reference like <a href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.RK45.html>scipy’s reference</a> or the <a href=https://doc.rust-lang.org/std/ >worlds best reference</a> is missing.</p> <p>Let’s explore Julia’s references and see what they do wrong.</p> <p>Let’s say you have a variable and the data you are interested in is somewhere hidden in its deeply nested datatype. In rust, you would first use rls or rust-analyze to find the name of the datatype. Then you can run <code>cargo doc --open</code> which will generate html documentation about this datatype. Each datatype is either a Product-Type (a.k.a. a structure) or a Sum-Types (a.k.a. an Enum). The generated documentation will contain links to the fields of the structures or enums. By recursively looking through this tree, you can find what you are looking for.</p> <p>So, lets try the same thing in Julia. To find the name of the datatype, there is the <code>typeof(var)</code> command in Julia. In my numerics code, this once returned</p> <pre><code>julia&gt; typeof(sol)
    SciMLBase.ODESolution{Float64, 2, Vector{Vector{Float64}}, Nothing, Nothing, Vector{Float64}, Vector{Vector{Vector{Float64}}}, SciMLBase.ODEProblem{Vector{Float64}, Tuple{Float64, Float64}, false, brüssel_conf, SciMLBase.ODEFunction{false, typeof(limit_dgl), UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing}, Base.Iterators.Pairs{Symbol, DiffEqBase.ContinuousCallback{var&quot;#condition#28&quot;{Float64, Vector{Float64}}, var&quot;#affect!#29&quot;, var&quot;#affect!#29&quot;, typeof(DiffEqBase.INITIALIZE_DEFAULT), typeof(DiffEqBase.FINALIZE_DEFAULT), Float64, Int64, Nothing, Int64}, Tuple{Symbol}, NamedTuple{(:callback,), Tuple{DiffEqBase.ContinuousCallback{var&quot;#condition#28&quot;{Float64, Vector{Float64}}, var&quot;#affect!#29&quot;, var&quot;#affect!#29&quot;, typeof(DiffEqBase.INITIALIZE_DEFAULT), typeof(DiffEqBase.FINALIZE_DEFAULT), Float64, Int64, Nothing, Int64}}}}, SciMLBase.StandardODEProblem}, OrdinaryDiffEq.Tsit5, OrdinaryDiffEq.InterpolationData{SciMLBase.ODEFunction{false, typeof(limit_dgl), UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing}, Vector{Vector{Float64}}, Vector{Float64}, Vector{Vector{Vector{Float64}}}, OrdinaryDiffEq.Tsit5ConstantCache{Float64, Float64}}, DiffEqBase.DEStats}</code></pre> <p>As if this weren’t bad enough the inline help also is rather limited</p> <pre><code>help?&gt; ODESolution
search: ODESolution RODESolution

  struct ODESolution{T, N, uType, uType2, DType, tType, rateType, P, A, IType, DE} &lt;: SciMLBase.AbstractODESolution{T, N, uType}

help?&gt; SciMLBase.AbstractODESolution
  abstract type AbstractODESolution{T, N, S} &lt;: SciMLBase.AbstractTimeseriesSolution{T, N, S}

help?&gt; SciMLBase.AbstractTimeseriesSolution
  abstract type AbstractTimeseriesSolution{T, N, A} &lt;: AbstractDiffEqArray{T, N, A}

help?&gt; AbstractDiffEqArray
search: AbstractDiffEqArray

  No documentation found.

  Summary
  ≡≡≡≡≡≡≡≡≡

  abstract type AbstractDiffEqArray{T, N, A}

  Subtypes
  ≡≡≡≡≡≡≡≡≡≡

  DiffEqArray{T, N, A, B, C, D, E, F}
  SciMLBase.AbstractNoiseProcess{T, N, A, isinplace}
  SciMLBase.AbstractTimeseriesSolution{T, N, A}

  Supertype Hierarchy
  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

  AbstractDiffEqArray{T, N, A} &lt;: AbstractVectorOfArray{T, N, A} &lt;: AbstractArray{T, N} &lt;: Any</code></pre> <p><a href="https://diffeq.sciml.ai/dev/search/?q=ODESolution">Searching for <code>ODESolution</code> in the documentation</a> also shows no entry for ODESolution.</p> <p>This means that it is possible that you have a variable that contains the information you want, but it is virtually impossible to extract said information.</p> <p>The inline documentation is sadly not available online. Julia made me realize how great <code>cargo doc</code> is.</p> <h3 id=the-problem-with-free-functions><a href=#the-problem-with-free-functions>The problem with free functions</a></h3> <p>A tutorial alone is not enough, you need a chain of links from a starting point to the function/argument/datatype you want. The authors of Julia argued that member functions are a bad idea, because it connects a function to a specific datatype instead of multiple datatypes. But this is not without disadvantages: Let’s say you want to know the methods to modify a <code>Dict</code>. In e.g. <a href=https://doc.rust-lang.org/std/collections/struct.HashMap.html>rust</a> you can find those methods in the documentation of the <code>Dict</code> datatype. But if you execute <code>apropos("Dict")</code> in Julia you find both functions like <code>Base.mergewith</code>, but also stuff like <code>Base.setenv</code> or <code>Base.Cmd</code>.</p> <h2 id=hard-to-debug-due-to-bad-error-messages><a href=#hard-to-debug-due-to-bad-error-messages>Hard to debug due to bad error messages</a></h2> <p>I would consider myself a semi-experienced programmer. Less experienced than people who worked in the industry for years or decades, but certainly more experienced than the average scientist programmer. Julia made me feel like an absolute beginner again. <strong>Unlike other languages, even those I spent less time learning on, I hade trouble writing certain code or debugging certain errors that I would consider very basic.</strong> And I don’t mean that my solution looked unelegant, like the code of a beginner. No, I was literally not able to write certain <em>basic</em> things myself.</p> <p>An example can be found <a href=https://github.com/SciML/SimpleDiffEq.jl/issues/48>here</a>.</p> <h2 id=dynamic-typing><a href=#dynamic-typing>Dynamic Typing</a></h2> <p>Julia is a dynamically typed programming language. Julia <em>feels</em> way more dynamically typed than e.g. Python. Typical Julia code (ab-)uses the features enabled by dynamic typing way more than typical python code. I do not like dynamic typing and Julia only reinforced that opinion. The error messages are worse and debugging is harder, because Julia is dynamically typed. One of the things I find weird is that a scalar can sometimes be treated like a vector with one element and a NxM matrix can sometimes be treated like a vector with N times M elements: I.e.</p> <div class=sourceCode id=cb3><pre class="sourceCode julia"><code class="sourceCode julia"><span id=cb3-1><a href=#cb3-1 aria-hidden=true tabindex=-1></a>vector <span class=op>=</span> [<span class=fl>1</span>, <span class=fl>2</span>]</span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true tabindex=-1></a>scalar <span class=op>=</span> <span class=fl>3</span></span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true tabindex=-1></a>matrix <span class=op>=</span> [<span class=fl>4</span> <span class=fl>5</span>;<span class=fl>6</span> <span class=fl>7</span>]</span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true tabindex=-1></a><span class=cf>for</span> el <span class=kw>in</span> vector</span>
<span id=cb3-5><a href=#cb3-5 aria-hidden=true tabindex=-1></a>    <span class=fu>println</span>(el)</span>
<span id=cb3-6><a href=#cb3-6 aria-hidden=true tabindex=-1></a><span class=cf>end</span></span>
<span id=cb3-7><a href=#cb3-7 aria-hidden=true tabindex=-1></a><span class=cf>for</span> el <span class=kw>in</span> scalar</span>
<span id=cb3-8><a href=#cb3-8 aria-hidden=true tabindex=-1></a>    <span class=fu>println</span>(el)</span>
<span id=cb3-9><a href=#cb3-9 aria-hidden=true tabindex=-1></a><span class=cf>end</span></span>
<span id=cb3-10><a href=#cb3-10 aria-hidden=true tabindex=-1></a><span class=cf>for</span> el <span class=kw>in</span> matrix</span>
<span id=cb3-11><a href=#cb3-11 aria-hidden=true tabindex=-1></a>    <span class=fu>println</span>(el)</span>
<span id=cb3-12><a href=#cb3-12 aria-hidden=true tabindex=-1></a><span class=cf>end</span></span></code></pre></div> <p>prints the numbers 1-7.</p> <h2 id=performance><a href=#performance>Performance</a></h2> <p>Julia is advertised as a fast language. Whether Julia fulfills this promise depends on how one defines “performance”. One way would be to do what <a href=https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html>the debian benchmarksgame</a> did and implement a simple problem with a hot loop in this language. For example, this is calculates the integral of a function (see https://en.wikipedia.org/wiki/Riemann_sum#Left_Riemann_sum)</p> <div class=sourceCode id=cb4><pre class="sourceCode julia"><code class="sourceCode julia"><span id=cb4-1><a href=#cb4-1 aria-hidden=true tabindex=-1></a><span class=kw>function</span> <span class=fu>integrate</span>(func, a,b, N)</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true tabindex=-1></a>    sum <span class=op>=</span> <span class=fl>0</span></span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true tabindex=-1></a>    step <span class=op>=</span> (b<span class=op>-</span>a)<span class=op>/</span>N</span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true tabindex=-1></a>    <span class=cf>for</span> i <span class=kw>in</span> <span class=fl>1</span><span class=op>:</span>N</span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true tabindex=-1></a>        sum <span class=op>+=</span> <span class=fu>func</span>(a<span class=op>+</span>i<span class=op>*</span>step)<span class=op>*</span>step</span>
<span id=cb4-6><a href=#cb4-6 aria-hidden=true tabindex=-1></a>    <span class=cf>end</span></span>
<span id=cb4-7><a href=#cb4-7 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> sum</span>
<span id=cb4-8><a href=#cb4-8 aria-hidden=true tabindex=-1></a><span class=kw>end</span></span></code></pre></div> <p>this code not only looks nice, but is basically as fast as it gets. So, promise fulfilled. On the other hand, if you would e.g. run this code</p> <div class=sourceCode id=cb5><pre class="sourceCode julia"><code class="sourceCode julia"><span id=cb5-1><a href=#cb5-1 aria-hidden=true tabindex=-1></a><span class=im>using</span> <span class=bu>Plots</span></span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true tabindex=-1></a><span class=im>using</span> <span class=bu>DifferentialEquations</span></span></code></pre></div> <p>it takes around 350 seconds on my machine, 20 seconds if it is already precompiled. Due to its jit, Julia sets new records for slowness. This is far slower than similar python code, slower than similar rust code, if you do an incremental build and sometimes even slower than rust code, if you include the time a clean build takes. The “you can run the code without compilation” advantage of an interpreted language is therefore completely gone. This is the kind of slowness that impacts your workflow. I spend a significant amount of the work-time waiting for this jit-compilation, also known as compile time latency or TTFP (time to first plot). This problem is increased by the fact that updating Julia with <code>pacaur -Syu</code> forces a recompilation. This slowness affects other software written in Julia as well. For example, my editor formats on save. For most languages, the formatting time-delay is not noticable, but for Julia it sometimes took more than 10 seconds.</p> <p>There are ways around the <code>using ...</code>-is-slow issue. Since <code>using ...</code> is only slow if you run it the first time in this julia-interpreter-process, the solution is to always keep the julia-interpreter-process running. E.g. vscode has a <a href=https://open-vsx.org/extension/julialang/language-julia>julia extension</a> with the <code>Julia: Execute File in REPL</code> command, which takes the contents of the currently open file and puts it into the running Interpreter. But this comes with other problems: Now, you have hidden state, the output does not solely depend on your code, but also on older versions of your code. If, for example, you change</p> <div class=sourceCode id=cb6><pre class="sourceCode julia"><code class="sourceCode julia"><span id=cb6-1><a href=#cb6-1 aria-hidden=true tabindex=-1></a><span class=kw>function</span> <span class=fu>func</span>(x<span class=op>::</span><span class=dt>Int</span>)</span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true tabindex=-1></a>    <span class=op>...</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true tabindex=-1></a><span class=kw>end</span></span></code></pre></div> <p>to</p> <div class=sourceCode id=cb7><pre class="sourceCode julia"><code class="sourceCode julia"><span id=cb7-1><a href=#cb7-1 aria-hidden=true tabindex=-1></a><span class=kw>function</span> <span class=fu>func</span>(x)</span>
<span id=cb7-2><a href=#cb7-2 aria-hidden=true tabindex=-1></a>    <span class=op>...</span></span>
<span id=cb7-3><a href=#cb7-3 aria-hidden=true tabindex=-1></a><span class=kw>end</span></span></code></pre></div> <p>, <code>func(123)</code> will still execute the old code. This is both tricky to debug and forces you to restart the interpreter, which can take a while since <code>using ...</code> is slow. Also, you cannot add/remove/change fields of a <code>struct</code> without restarting the interpreter or running into <a href=https://github.com/JuliaLang/julia/issues/42109>other problems</a>.</p> <p>The idea of “You only need to start the interpreter once a day” failed for me.</p> <h2 id=confusion-about-the-recommended-way.><a href=#confusion-about-the-recommended-way.>Confusion about the “recommended” way.</a></h2> <p>For every software, it is important that there is no confusion about what the “official” “recommended” “proper” way is. If there are multiple ways to do something and you do not know how you should do it, you might choose a solution that seems to work, but leads to problems further down the road. Examples of this Problem occurring in Julia:</p> <ul> <li><p>You installed the <a href=https://archlinux.org/packages/extra/x86_64/julia/ >package in the official ArchLinux repos called “julia”</a>? Might seem like a good idea and will mostly work, but it is <a href=https://wiki.archlinux.org/title/Julia#Installation>unsuported by upstream</a> and can lead to <a href=https://github.com/SciML/Sundials.jl/issues/334>linking errors during runtime</a>.</p></li> <li><p>How should you split code among multiple files? <a href=https://www.reddit.com/r/Julia/comments/hwxpgm/beginner_question_files_modules_and_include_vs/ >Good question</a>.</p></li> <li><p><a href=https://discourse.julialang.org/t/blog-post-about-my-experiences-with-julia/79976/72>Confusion about the recommended workflow exists.</a> For example <code>Julia: Execute File in REPL</code> in combination with <code>Revise</code> is <a href=https://discourse.julialang.org/t/blog-post-about-my-experiences-with-julia/79976/67>wrong</a>,</p></li> </ul> <p>Does confusion about the “recommended” way exist in other languages? Absolutely, this is a problem in software engineering in general, not just a problem in Julia. Is it worse in Julia than in other languages? Maybe, even though C++ is probably the king here. Also, shout-out to the developers of the rust language. They do a phenomenal job at preventing this kind of confusion.</p> <h2 id=other-stuff><a href=#other-stuff>Other Stuff</a></h2> <ul> <li><p><code>Go To Definition</code> commands in editors work worse for Julia than for other languages.</p></li> <li><p>The tooling around Julia seems very immature. The Julia formatter is slow - sometimes formatting a small file took over 10 seconds - and <a href=https://github.com/domluna/JuliaFormatter.jl/issues/465>buggy</a>.</p> <ul> <li><code>Plots.jl</code> does not allow zooming if used in vscode.</li> <li><a href=https://github.com/julia-vscode/julia-vscode/issues/1788>VSCode does not show you what was printed just before a crash.</a></li> </ul></li> <li><p>While the tooling is bad, the scientific ecosystem is enormous. For every numerical method there is a library. This is the main advantage over Rust.</p></li> <li><p>Variable Binding can be confusing:</p> <div class=sourceCode id=cb8><pre class="sourceCode julia"><code class="sourceCode julia"><span id=cb8-1><a href=#cb8-1 aria-hidden=true tabindex=-1></a><span class=kw>function</span> <span class=fu>f</span>(du, u, p, t)</span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true tabindex=-1></a>    du <span class=op>.=</span> <span class=fl>2.0</span></span>
<span id=cb8-3><a href=#cb8-3 aria-hidden=true tabindex=-1></a>    <span class=pp>@assert</span> du <span class=op>==</span> [<span class=fl>2.0</span>]</span>
<span id=cb8-4><a href=#cb8-4 aria-hidden=true tabindex=-1></a><span class=kw>end</span></span></code></pre></div> <p>is not the same as</p> <div class=sourceCode id=cb9><pre class="sourceCode julia"><code class="sourceCode julia"><span id=cb9-1><a href=#cb9-1 aria-hidden=true tabindex=-1></a><span class=kw>function</span> <span class=fu>f</span>(du, u, p, t)</span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true tabindex=-1></a>    du <span class=op>=</span> [<span class=fl>2.0</span>]</span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true tabindex=-1></a>    <span class=pp>@assert</span> du <span class=op>==</span> [<span class=fl>2.0</span>]</span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true tabindex=-1></a><span class=kw>end</span></span></code></pre></div> <p>because only the first has an effect on a variable in the callers scope. This might be confusing.</p></li> </ul> <h2 id=conclusion><a href=#conclusion>Conclusion</a></h2> <p>Hot loops in Julia are quite fast, but you have to wait quite long for your program to start up.</p> <p>The Julia tooling is quite immature and buggy, at least compared to rust or python. The ecosystem for scientific libraries however, is great and gigantic.</p> <p>Julia has really nice, short syntax for mathematic equations. Compared to other languages, your numerics code will be much shorter. The problem is that this short code will take longer to write, because dynamic typing, bad reference documentation makes writing and debugging Julia code harder.</p> <p>After a while, I decided to rewrite parts of my code in Rust. Rust code is much more verbose and I had to implement basic numerical methods since rust has few numeric libraries, so the code was much longer. However, it was still faster to write, because rust has a better type system, reference documentation, error messages and a mature ecosystem. My Rust code greatly outperformed the Julia code.</p> <h2 id=other-opinions><a href=#other-opinions>Other Opinions</a></h2> <p>I posted this article on the <a href=https://discourse.julialang.org/t/blog-post-about-my-experiences-with-julia>Julia discourse server</a> and got quite a lot of comments.</p> <p><a href=https://viralinstruction.com/posts/badjulia/#the_iterator_protocol_is_weird_and_too_hard_to_use>Jakob also wrote about Julia.</a> I agree with his love towards rust and the sections - Compile time latency - Large memory consumption - Julia can’t easily integrate into other languages - Weak static analysis - Abstract interfaces are unenforced and undiscoverable</p> <p>I partially disagree with his “The ecosystem is immature” section because Julia has <em>a lot</em> of scientific packages.</p> <p>His <a href=https://viralinstruction.com/posts/uniontypes/ >post about union types vs sum types</a> is also great at highlighting a difference between Julia and Rust.</p> <p><a href=https://vitaut.net/posts/2016/giving-up-on-julia/ >Victor Zverovich also wrote about Julia.</a></p> <p><a href=https://yuri.is/not-julia/ >Yuri Vishnevsky thinks Julia has a correctness problem.</a></p> <h2 id=updates><a href=#updates>Updates</a></h2> <p>In December 2022, <a href="https://news.ycombinator.com/item?id=33905019">the developer of SciML responded that most of the things I complained about have seen significant improvement</a>.</p> </article> </div> <hr> <center> <footer> <a href=/ >Home</a> | <a href=mailto:volker.weissmann@gmx.de>volker.weissmann@gmx.de</a> </footer> </center> </body> </html> 